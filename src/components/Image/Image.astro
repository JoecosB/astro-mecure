---
import BlurHash from './BlurHash';
import { getImage  } from 'astro:assets';
import importAssets from '@/utils/importAssets';
import { DEV, DIST_DIR, FS_PREFIX } from '@/constants';
import urlJoin from 'url-join';
import { imageToHashBase64 } from './converter';
import { twMerge } from 'tailwind-merge';
import type { RemoteImageProps as AstroRemoteImageProps, LocalImageProps as AstroLocalImageProps } from 'astro:assets';
import type { HTMLAttributes } from 'astro/types';

type ExtraProps = {
  src: string | ImageMetadata | Promise<{
    default: ImageMetadata;
  }>;
  alt?: string;
  onlyBlur?: boolean;
};
type LocalImageProps = Omit<AstroLocalImageProps, keyof ExtraProps> & ExtraProps;
type RemoteImageProps = Omit<AstroRemoteImageProps, keyof ExtraProps> & ExtraProps;
export type Props = LocalImageProps | RemoteImageProps;
const {
  src,
  class: className,
  onlyBlur = false,
  ...rest
} = Astro.props;

function transformVitePath(path: string) {
  if (DEV) {
    if (path.startsWith(FS_PREFIX)) {
      const prunedPath = new URL(path, 'http://localhost').pathname
      return prunedPath.slice(FS_PREFIX.length)
    } else {
      throw new Error(`Path "${path}" is not started with ${FS_PREFIX}`)
    }
  } else {
    return urlJoin(process.cwd(), DIST_DIR, path)
  }
}

function isValidUrl(str: string): boolean {
	try {
		new URL(str);
		return true;
	} catch {
		return false;
	}
}

function isRemoteUrl(src: string) {
	return isValidUrl(src) || src.startsWith('/');
}

const isRemoteImage = typeof src === 'string' && isRemoteUrl(src);
const image = await getImage({
  src: typeof src === 'string' ? await (
    isRemoteImage ? src : importAssets(src)
  ) : (
    src instanceof Promise ? (await src).default : src
  ),
  ...rest,
})
const additionalAttributes: HTMLAttributes<'img'> = {};
if (image.srcSet.values.length > 0) {
  additionalAttributes.srcset = image.srcSet.attribute;
}
const hasBlurHash = image.options.format !== 'svg' && !isRemoteImage;
const blurhash = hasBlurHash ? await imageToHashBase64(
  transformVitePath((image.options.src as ImageMetadata).src)
) : undefined;
---
{onlyBlur ? (
  blurhash && (
    <BlurHash
      className={className ?? undefined}
      src={image.src}
      blurhash={blurhash}
      fadeOut={false}
      client:load
    />
  )
) : (
  <div class={twMerge(
    "relative inline-block",
    className
  )}>
    {<img src={image.src} class="w-full h-full object-cover" {...additionalAttributes} {...image.attributes} />}
    {blurhash && (
      <BlurHash
        className="absolute inset-0"
        src={image.src}
        blurhash={blurhash}
        client:load
      />
    )}
  </div>
)}

